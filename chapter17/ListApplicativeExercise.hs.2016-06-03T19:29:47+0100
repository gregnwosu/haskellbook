module ListApplicativeExercise where


append :: List a -> List a -> List a
append Nil ys = ys
append (Cons x xs ) ys = Cons x $ xs `append` ys

fold :: (a -> b -> b ) -> b -> List a -> b
fold _ b Nil = b
fold f b (Cons h t) = f h (fold f b t)

data List a =
  Nil |
  Cons a (List a)
  deriving (Eq, Show)

instance Functor List where
  fmap = undefined

instance Applicative List where
  pure = (`Cons` Nil)
  (Cons f fs) <*> (Cons x xs) = undefined
